diff --git a/create_gantt.py b/create_gantt.py
index cd75a0d..d282193 100644
--- a/create_gantt.py
+++ b/create_gantt.py
@@ -23,14 +23,9 @@ research = gantt.Project("Research", color="#FFA52C")
 
 research_tasks = [
     gantt.Task("Preliminary research", start=date(2020, 2, 3), duration=5*5),
-    gantt.Task("Research sub-question 1", start=date(2020, 3, 2), duration=3),
-    gantt.Task("Research sub-question 2", start=date(2020, 3, 5), duration=3),
-    gantt.Task("Research sub-question 3", start=date(2020, 3, 10), duration=3),
-    gantt.Task("Research sub-question 4", start=date(2020, 3, 13), duration=3),
-    gantt.Task("Research sub-question 5", start=date(2020, 3, 18), duration=3),
-    gantt.Task("Put it all together", start=date(2020, 3, 23), duration=5),
+    gantt.Task("Research", start=date(2020, 3, 2), duration=5*4),
+    gantt.Task("Put it all together", start=date(2020, 3, 30), duration=5),
     gantt.Task("Workshop concluding and analysing", start=date(2020, 3, 24), duration=1, color=WORKSHOP),
-    gantt.Task("Legal and Licensing Workshop", start=date(2020, 4, 15), duration=3),
 ]
 
 for task in research_tasks:
@@ -42,7 +37,8 @@ sync_tasks = [
     gantt.Task("Synchronise with Matija", start=the_date, duration=1) for the_date in (date(2020, 2, 18) + timedelta(i) for i in (x*14 for x in range(9)))
 ]
 sync_tasks += [
-    gantt.Task("On-location meeting with Matija and Martin", start=date(2020, 4, 6), duration=1)
+    gantt.Task("On-location meeting with Matija and Martin", start=date(2020, 4, 6), duration=1),
+    gantt.Task("Product retrospective", start=date(2020, 5, 26), duration=1),
 ]
 
 for task in sync_tasks:
@@ -51,9 +47,9 @@ for task in sync_tasks:
 implementation = gantt.Project("Implementation", color="#008018")
 
 implementation_tasks = [
-    gantt.Task("Create requirements analysis", start=date(2020, 3, 30), duration=3),
-    gantt.Task("Familiarise with tools", start=date(2020, 3, 30), duration=5),
-    gantt.Task("Implementation", start=date(2020, 4, 6), duration=5*9),
+    gantt.Task("Create requirements analysis", start=date(2020, 4, 13), duration=3),
+    gantt.Task("Familiarise with tools", start=date(2020, 4, 13), duration=5),
+    gantt.Task("Implementation", start=date(2020, 4, 20), duration=5*7),
     gantt.Task("Hand over proof-of-concept", start=date(2020, 6, 5), duration=1),
 ]
 
diff --git a/plan.md b/plan.md
index 7707165..77183e3 100644
--- a/plan.md
+++ b/plan.md
@@ -286,6 +286,9 @@ By and large, the \gls{copyright} and licensing of a file is defined in its
 comment header. In Liferay Portal, the Java files have a standardised header as
 shown in listing \ref{lst:java-header}.
 
+When Liferay DXP---which is licensed under a proprietary EULA---is released,
+these headers are replaced.
+
 ```{#lst:java-header caption="Comment header that contains Liferay's licensing blurb."}
 /**
  * Copyright (c) 2000-present Liferay, Inc. All rights reserved.
@@ -309,8 +312,19 @@ worst; use of obsolete 'All rights reserved', which is neither needed nor true,
 as the very next line gives rights through a \gls{foss} \gls{license}; does not
 include a contact point to the \gls{copyright-holder}."
 
-When Liferay DXP---which is licensed under a proprietary EULA---is released,
-these headers are replaced.
+@liferay-outbound now mandates the use of a different header, but it has not
+been widely implemented yet. The new header can be seen in listing
+\ref{lst:reuse-header}.
+
+```{#lst:reuse-header caption="New copyright and licensing header template for Liferay."}
+/**
+ * SPDX-FileCopyrightText: © {year_of_creation} Liferay, Inc. <https://liferay.com>
+ * SPDX-License-Identifier: {spdx_license_short_identifier}
+ */
+```
+
+The new Liferay policy is informed by the REUSE project [@fsfe-reuse]. See
+section \ref{spdx-reuse}.
 
 ### Copyright assignment {#copyright-assignment}
 
@@ -368,41 +382,67 @@ some qualities of the ideal situation:
 
 ## Goals {#goals}
 
-In coming up with a goal, it was quickly evident that it would be difficult to
-formulate the main goal into a SMART goal. So instead of doing that, a broader
-goal was chosen, with the implicit understanding that the goal would be met if
-all SMART sub-goals are completed.
+The main goal of the project is to *improve and automate \gls{inbound} and
+\gls{outbound} licensing compliance*. However, this goal is not very SMART, so a
+different SMART main goal has been formulated. As follows:
 
-The main goal of the project is:
+> Automatically check licensing of all **\gls{inbound}** third-party code, and
+> follow industry best-practices by providing unified and unambiguous licensing
+> information for all **\gls{outbound}** code.
 
-> Improve and automate \gls{inbound} and \gls{outbound} licensing compliance.
+This main goal is necessarily two-pronged, with an equal focus on \gls{inbound}
+and \gls{outbound} licensing. This is a minor annoyance, but unavoidable.
+Focusing exclusively on one or the other would not solve the stated problems in
+chapter \ref{context}.
 
-The sub-goals of the project are informed by the desires of Liferay. They are as
-follows:
+Therefore it is likely---but not necessary---that two technological solutions
+are provided instead of one, or that a single technological solution is provided
+with a very clear split down the middle between the \gls{outbound} licensing
+component and the \gls{inbound} licensing component.
 
-### Follow industry best-practices by providing unified and unambiguous licensing information in all source code files {#goal-reuse}
+### Automate verification of inbound licensing {#goal-inbound}
 
-This resolves the problem mentioned in section \ref{license-headers}.
-@liferay-outbound now mandates the use of a different header, but it has not
-been implemented yet. The new header can be seen in listing
-\ref{lst:reuse-header}.
+All code that enters the project must have its licensing checked. More often
+than not, it will be a contribution authored by an employee, which means that
+the \gls{inbound} licensing is not a concern. If the employee commits code that
+was authored by somebody else, however, the licensing must be double-checked.
 
-```{#lst:reuse-header caption="New copyright and licensing header template for Liferay."}
-/**
- * SPDX-FileCopyrightText: © {year_of_creation} Liferay, Inc. <https://liferay.com>
- * SPDX-License-Identifier: {spdx_license_short_identifier}
- */
-```
+The method of implementation is not yet certain, and will require research and
+deliberation. Some options are concretely mentioned here to give this goal some
+more tangibility. Preliminary research suggests that incoming libraries could be
+checked against their declared manifest, or against a public database that holds
+the licensing information of many packages. Alternatively, the code could be
+verified against a "plagiarism checker" on a snippet level, but this might be
+too complex and/or resource-intensive.
 
-The new Liferay policy is informed by the REUSE project [@fsfe-reuse]. See
-section \ref{spdx-reuse}.
+To reduce the complexity of this goal into tangible parts, it would be fair to
+split it up into a few sub-goals:
+
+- Write a mechanism that automatically checks whether \gls{inbound} code is
+  first-party or third-party.
+
+- Write a mechanism that automatically checks the licensing of \gls{inbound}
+  third-party code.
+
+- Write a mechanism that verifies whether the licensing of \gls{inbound}
+  third-party code is compatible according to @liferay-inbound.
 
-There are going to be some challenges in implementing this policy, but it is
-equally important that the policy be tested against. Therefore, this sub-goal
-has one sub-goal of its own:
+- Write a mechanism that flags Legal if a problem is detected.
 
-- Automatically verify (lint) the codebase against Liferay's \gls{outbound}
-  licensing policy.
+### Automate verification of outbound licensing {#goal-reuse}
+
+Automating \gls{outbound} licensing compliance is closely related to the problem
+in section \ref{license-headers}. There are going to be some challenges in
+implementing this policy, but it is equally important that the policy be tested
+against. Therefore, this goal presents the following sub-goals:
+
+- Write a mechanism that converts the licensing headers in Liferay's codebase to
+  the format found in listing \ref{lst:reuse-header}. This is a single-use
+  mass-conversion program that does not need to be maintained or rigorously
+  designed.
+
+- Write a mechanism that automatically verifies (lints) the codebase against
+  Liferay's \gls{outbound} licensing policy.
 
 There is one optional sub-goal. As described in section
 \ref{copyright-assignment} and section \ref{license-headers}, Liferay offers a
@@ -413,38 +453,13 @@ stems the following sub-goal:
   of Liferay Portal. See section \ref{liferay-portal}.
 
 This sub-goal might be tricky from a legal perspective, though, and remains
-entirely optional.
-
-### Automatically check licensing of all inbound third-party code, and flag Legal if a problem is detected
-
-All code that enters the project must have its licensing checked. More often
-than not, it will be a contribution authored by an employee, which means that
-the \gls{inbound} licensing is not a concern. If the employee commits code that
-was authored by somebody else, however, the licensing must be double-checked.
-
-The method of implementation is not yet certain, and will require research.
-Preliminary research suggests that the code could be verified against a
-"plagiarism checker" and a decision tree. The complexity of such a plagiarism
-checker is much greater, however, because not only must one check for duplicity,
-but also for the licensing of the original code. The decision tree is as complex
-as the licensing policy that informs it.
-
-To reduce the complexity of the sub-goal into tangible parts, it would be fair
-to split this sub-goal up into a few more sub-goals:
-
-- Automatically check whether \gls{inbound} code is first-party or third-party.
-
-- Automatically check the licensing of \gls{inbound} third-party code.
-
-- Verify whether the licensing of \gls{inbound} third-party code is compatible
-  according to @liferay-inbound.
-
-- Flag Legal if a problem is detected.
+entirely optional. And it is, as far as this internship is concerned,
+out-of-scope from a software engineering perspective.
 
 ### Facilitate the production of a bill of materials that covers all outbound licensing {#goal-bom}
 
-**Important:** This is an *optional* goal that may not be completed if time is
-tight. If time is not tight, or if another step went much quicker than
+**Important:** This is an *optional* sub-goal that may not be completed if time
+is tight. If time is not tight, or if another step went much quicker than
 anticipated, this goal is an excellent extension of the internship.
 
 When the goal in section \ref{goal-reuse} is completed, it should be much easier
@@ -465,7 +480,7 @@ material information.
 The desired granularity of the output is left unspecified and depends on the
 available time.
 
-## Deliverables
+## Deliverables {#deliverables}
 
 By the end of the internship, several things will be delivered. It is difficult
 to anticipate the exact details, because the research is intended to discover
@@ -481,11 +496,17 @@ the best solution. Nevertheless, a curt overview of deliverables:
   this report.
 
 - A product, or a combination of products, that automate \gls{copyright} and
-  licensing compliance.
+  licensing compliance. Section \ref{goal-inbound} and \ref{goal-reuse} provide
+  rough sketches of the requirements of these products.
+
+- A simple program, as described in section \ref{goal-reuse}, that mass-converts
+  Liferay's codebase to use the new licensing headers.
 
-- Documentation that assists in the integration of the delivered product(s).
+- Optional: A program, as described in section \ref{goal-bom}, that produces a
+  bill of materials for Liferay's products.
 
-- A pull request that alters the licensing headers in the source code.
+- Documentation that assists in the integration of the delivered product(s). See
+  section \ref{out-of-scope}
 
 # Research {#research}
 
@@ -501,56 +522,39 @@ to know the licensing of \gls{inbound} code, and wishes to verify its
 \gls{outbound} licensing. They wish to do these things in an automated fashion.
 Reorder the words, and this becomes the main question of research:
 
-> Given Liferay’s demands, requirements and limitations, what are suitable
-> solutions for automating Liferay's \gls{inbound} and \gls{outbound} licensing
-> policies?
+> Given Liferay's demands, requirements and limitations, what is the most
+> suitable solution for automating Liferay's \gls{inbound} and \gls{outbound}
+> licensing policies?
 
 ## Sub-questions {#sub-questions}
 
-Because main questions need sub-questions, this section details five of them.
+Because main questions need sub-questions, this section details three of them.
+There had been five in the earlier submission, but due to time constraints, it
+has been trimmed down to three.
 
-The first two sub-questions directly elaborate on the main question in ways that
-are hopefully obvious:
+@current. What is the current process of licensing compliance?
 
-@needs. What are the demands, requirements and limitations of Liferay?
+@needs. What are the demands, requirements and limitations of Liferay in the
+context of automating their licensing policies?
 
 @solutions. What are the available technical solutions in the field of
-licensing compliance? What are their qualities?
+licensing compliance? Which of these are suitable for automating Liferay's
+licensing policies?
+
+Question @current exists to create an understanding of the current situation.
+With that understanding, it becomes much easier to imagine how the process might
+be automated.
 
 Question @needs seeks to define some important terms in the main question.
+Acquiring a deeper understanding of Liferay's wants helps the project to focus
+on those specific wants.
+
 Question @solutions seeks to acquire information about existing technical
 approaches to adjacent problems, if any. It will also zoom in on the extent of
 automation: Which scenarios should require manual intervention by Legal or
 Engineering? These existing technical solutions may inform the product, or may
 be consumed by the product.
 
-The next questions explore aspects that are directly tangential to the main
-question. These aspects will be important to research.
-
-@current. What is the current process of licensing compliance?
-
-@methods. What are the possible methods of detecting the \gls{inbound}
-licensing of code? What are their qualities?
-
-Question @current exists to create an understanding of the current situation.
-With that understanding, it becomes much easier to imagine how the process might
-be automated.
-
-Question @methods looks similar to question @solutions, but they are in truth
-extremely different. Where question @solutions is focused on the technical
-aspect and available technical solutions, question @methods is non-technical and
-should not necessitate a single line of code. It is concerned with extracting
-information from data. Figuring out how to do this is important for the product.
-
-Which leaves the last question:
-
-@measure. Is it possible to measure the quality of licensing? If so, how?
-
-This question is slightly out-of-scope for main question, but completely
-in-scope for the requirements analysis and project goals, which is why it is
-here. One of the goals of the project is to improve the licensing. The answer
-to question @measure allows us to test the quality of the delivered work.
-
 ## Definitions
 
 In line with Verhoeven [-@verhoeven-2018, chap. 5], find here a clarification of
@@ -596,43 +600,75 @@ sources that are likely to be useful:
 
 Some of these sources are also used in this document.
 
-## Method
+## Methods
 
 This section describes the intended methods of research for each sub-question.
-These methods are sourced from @ictresearchmethods. They are not further
-described for the sake of brevity---the aforementioned source contains their
-descriptions. The rationales are described, however.
+These methods are sourced from @ictresearchmethods. The methods are broadly
+defined and a rationale for each method is given.
+
+### What is the current process of licensing compliance?
+
+In order to assess the current processes, an *expert interview* will be
+conducted with Matija Šuklje. The expert interview will focus on a handful of
+things:
+
+- What are the steps that are taken when a licensing compliance issue pops up?
+- What is the most common licensing compliance issue?
+- Where in the process does Liferay lose the most time?
 
-#### What are the demands, requirements and limitations of Liferay? {-}
+There will doubtlessly be more questions when the interview occurs, but these
+three questions should reveal the process and its pain points.
 
-- Stakeholder analysis --- The stakeholders assuredly possess the knowledge to
-  answer this question.
+The rationale for an expert interview is simple: There is no doubt in my mind
+that an expert knows the process well, and is familiar enough with the process
+to detect its pain points.
 
-#### What are the available technical solutions in the field of licensing compliance? What are their qualities? {-}
+### What are the demands, requirements and limitations of Liferay in the context of automating their licensing policies?
 
-- Available product analysis --- Requires no rationale.
+One part of this sub-question is extremely easy to address: @liferay-inbound and
+@liferay-outbound already give a lot of information on Liferay's requirements
+from a policy perspective. Researching these documents is *document analysis*.
 
-#### What is the current process of licensing compliance? {-}
+But those are only the things that are written down. It is probable that there
+are other wants or restrictions that are not black-on-white. To discover those,
+I will *explore user requirements*. Exploring user requirements will be a number
+of interviews with people who are somehow related to the project. These people
+potentially include (depending on time and availability):
 
-- Expert interview --- An expert can perfectly describe the current process.
-- Observation --- Observing the current process may give insights that do not
-  arise from the interview.
+- Someone from Legal.
+- Someone from QA.
+- Someone from Engineering. This is also probably an end-user.
 
-#### What are the possible methods of detecting the inbound licensing of code? What are their qualities? {-}
+### What are the available technical solutions in the field of licensing compliance? Which of these are suitable for automating Liferay's licensing policies?
 
-- Brainstorm --- This is a practical problem that could be solved in multiple
-  ways. Because the likely methods are currently unknown, they could be
-  unearthed through brainstorming.
-- Expert interview --- An interview with an expert can uncover the qualities of
-  the discovered methods.
+There are various existing technical solutions in the field of licensing
+compliance. An *available product analysis* is made of these solutions. In
+co-operation with Matija, a shortlist was created. The shortlist consists of:
+
+- ClearlyDefined
+- FOSSID
+- FOSSology
+- OSS Review Toolkit
+- REUSE
+- ScanCode
+- SW360
 
-#### Is it possible to measure the quality of licensing? If so, how? {-}
+The method of evaluating these solutions is a simple linear path:
 
-- Literature study --- This question is highly theoretical. It is possible that
-  someone else has written about this before.
-- Available product analysis --- This method may or may not be relevant. Someone
-  may have written a product that measures licensing quality. Analysing these
-  products may give insight into how the measurements are done.
+1. Read about the product in its existing documentation.
+
+2. Install the product (if applicable). This step seems superfluous, but was
+   retroactively introduced into the method, as will become evident in the
+   results of some of the solutions.
+
+3. Use the product, preferably on Liferay Portal. This step is ill-defined
+   because of the variation between the solutions. It is exploratory
+   observation---discovering the unknown.
+
+4. Read other people's reviews or comments about the product.
+
+Once these steps are through, the findings are assessed to determine their
+applicability to this internship.
 
 ## Requirements analysis
 
@@ -649,6 +685,8 @@ more-or-less chronological, but become asynchronous as implementation begins.
 
 ## Plan de campagne
 
+- Attend the workshop.
+
 - Discuss the problems with Matija.
 
 - Create a plan de campagne.
@@ -666,6 +704,8 @@ more-or-less chronological, but become asynchronous as implementation begins.
 - Perform research. The exact activities are detailed in chapter \ref{research}
   and will not be repeated here.
 
+- Attend the workshop.
+
 - Document the research into the report.
 
 ## Synchronisation {#synchronisation}
@@ -675,6 +715,8 @@ more-or-less chronological, but become asynchronous as implementation begins.
 - Perhaps stating the obvious: Regularly communicate with Matija between the
   biweekly meetings to resolve issues early.
 
+- Product retrospective. See section \ref{retrospective}.
+
 ## Implementation
 
 - Create a requirements analysis from the conclusion of the research.
@@ -683,9 +725,9 @@ more-or-less chronological, but become asynchronous as implementation begins.
   catch up on a new programming language or framework).
 
 - Create a rudimentary high-level design for the product. This design need not
-  be thorough---it need only be sufficient to get started with the development
-  feedback loop. Most of the design will be informed by test-driven development.
-  See rationale in section \ref{tdd}.
+  be all-encompassing---it need only be sufficient to get started with the
+  development feedback loop. Most of the design will be informed by test-driven
+  development. See rationale in section \ref{tdd}.
 
 - Create all (anticipated) issues in an issue tracker.
 
@@ -701,7 +743,7 @@ more-or-less chronological, but become asynchronous as implementation begins.
 - Request code reviews during the creation of the product.
 
 - Write a separate tool that adjusts the headers to be compliant with the
-  \gls{outbound} policy.
+  \gls{outbound} policy. See section \ref{goal-reuse}.
 
 - Hand over the code to Engineering. The chances of seeing the product
   implemented in Liferay in the last weeks of the internship are slim, but it
@@ -716,6 +758,8 @@ more-or-less chronological, but become asynchronous as implementation begins.
 - Continuously document activities into the report. If this is diligently done,
   the hope is that it saves a lot of time at the end.
 
+- Attend the workshop.
+
 - Figure out a way to use visuals in a way that this plan de campagne has not.
 
 - After implementation is done, spend two or three weeks doing finishing touches
@@ -737,23 +781,30 @@ relatively simple.
 
 ## In-scope
 
-The goals of the project are well-defined in section \ref{goals}. Everything
-that furthers those goals is obviously within the boundaries of the project.
+A lot of the things that are in-scope are already defined in chapter
+\ref{project-definition}. Specifically section \ref{deliverables} has a good,
+concrete list of deliverables that this internship strives achieve. Section
+\ref{goals} lists the specific things that the software solution should strive
+to implement. These things, then, are all in-scope.
+
 Importantly, section \ref{goal-bom} lists an optional goal that may or may not
 be feasibly completed.
 
-During the first weeks of the implementation phase of the project, *definitions
-of done* will be produced that set the exact scope of the project. For now, the
-definition of done is a simple question: Are the goals in section \ref{goals}
-completed? The reason that the definitions of done will be produced during the
-early implementation phase is because, by then, it will be much clearer what the
-project looks like, what is feasible, and what problems are especially difficult
-to solve. These things are not clear yet.
+Other things that are within the boundaries of the project:
+
+- Research as described in chapter \ref{research}.
+- Software design.
+- Documentation.
+- Testing.
+- Reporting.
 
-Documentation and testing of the produced product is within the boundaries of
-the project.
+This is mostly just stating the obvious.
 
-## Out-of-scope
+It is difficult to be more specific in this section. The requirements analysis
+is not yet written, but that document would be a lot clearer in defining exactly
+what needs to be produced, and would therefore be in-scope.
+
+## Out-of-scope {#out-of-scope}
 
 As part of the internship, there will be communication/co-operation with the
 wider software licensing community. Any tasks that stem from that co-operation
@@ -763,18 +814,46 @@ professional development. See section \ref{spdx-reuse}.
 
 Although a product will be delivered during the internship, integration is
 out-of-scope. Someone within Liferay will---or will not---integrate the product
-into Liferay's internal systems.
+into Liferay's internal systems. This is Liferay's decision, and not within my
+control.
 
 In order to simplify the internship, every repository other than Liferay Portal
 (section \ref{liferay-portal}) is out-of-scope. The purpose of this project is
 to be applicable to other Liferay repositories as well, but for scope reasons,
-this internship will only focus on Liferay Portal.
+this internship will only focus on Liferay Portal. The rationale for this is
+that Liferay Portal is ultimately the most important project, and other
+repositories are not the most valuable use of time.
+
+It is likely that a second, smaller repository may be used for prototyping
+purposes. This is handy, but otherwise out-of-scope.
+
+This was briefly mentioned in section \ref{goal-inbound}: There is the
+possibility that a solution for \gls{inbound} licensing may work on a snippet
+level. It has been precalculated that this is likely to be extremely difficult
+and result in a lot of false positives. For these reasons, snippet-level
+analysis is out-of-scope unless there is a clear indication to the contrary.
 
 # Quality assurance {#quality-assurance}
 
-The quality of the product will be assured through three measures.
+This chapter details how the quality of the following things will be monitored
+and assured:
 
-## Test-driven development {#tdd}
+- The software design/architecture.
+- The product.
+- The code.
+
+The chapter also details general development methodology. This could have gone
+into chapter \ref{project-activities} instead, but I find it much more suitable
+in this chapter, because methodologies ultimately exist to deliver better
+products or services.
+
+## Measures
+
+The sections below describe the measures. An important common feature of these
+measures is that most of them are continuous and make heavy use of feedback
+loops.
+
+### Test-driven development {#tdd}
 
 Test-driven development (TDD) is a software development process in which test
 cases are written before the implementation is written. The tests inform the
@@ -782,6 +861,9 @@ design of the implementation. As an added bonus, you get a test suite that tests
 every single feature. The test suite is run regularly to guarantee that no new
 bugs have been introduced.
 
+Ideally, continuous testing is set up to run the tests for every commit. Whether
+this is possible is not yet certain.
+
 Test-driven development as a methodology does not mix well with up-front design.
 Writing the tests *is* the design process. For this reason, the up-front design
 will be high-level rather than low-level. This allows a lot of flexibility while
@@ -790,26 +872,156 @@ still providing some structure.
 An added benefit of test-driven development is that, ideally, you do not end up
 with more functionality than you strictly need.
 
-## Code review
+#### Up-front design
+
+The up-front design will be a component diagram or similar architectural
+overview. It will be submitted to engineers within Liferay to garner feedback.
+It will also be discussed with Matija Şuklje to get a rough understanding of
+whether the proposed solution solves the problems as envisioned. Matija is a
+technologically capable individual, but may not be able to read UML component
+diagrams. For that reason, some yet-to-be-determined alternative method of
+representation may be chosen.
 
-Though I will not receive a code review for every single feature or pull
-request, I will semi-regularly request code reviews to make sure that the
-written code is up-to-standard.
+At the end of the feedback loop, the design will be approved, and implementation
+may start.
 
-## Synchronisation with stakeholders
+### Code review
+
+I will regularly request code reviews for pull requests into the repository. A
+Liferay engineer will review the code, engage in a feedback loop, and eventually
+approve the pull request.
+
+Depending on the volume of contributions, there may not be enough engineering
+resources to review all pull requests. If that is the case, one of three things
+will happen:
+
+- The pull requests will happen at a delayed rate, and to prevent blockage, work
+  will continue in a separate branch.
+- *Or* only a portion of the pull requests will get code reviews. To make sure
+  that the code that went into the project without approval also gets reviewed,
+  I will schedule a weekly or biweekly meeting with an engineer to interactively
+  comb through the code together. Pair programming, except it's a code review.
+- Or a combination of the two.
+
+With any luck, the code reviews will be publicly visible on a code hosting
+website. This means that the reviews may be retroactively studied and verified.
+
+### Synchronisation with stakeholders
 
 In a scrum-like fashion, I will regularly synchronise with the primary
 stakeholder to make sure that the product delivers the features it should. These
 meetings are biweekly. See section \ref{synchronisation}.
 
+Furthermore, all important documents and steps will be synchronised with Matija.
+They won't be listed here in the interest of not bombarding the reader with
+repetition. The important take-away is that quality is improved by many checks
+along the way.
+
+#### Retrospective {#retrospective}
+
+Near the end of the implementation phase of the internship, I will
+retrospectively synchronise with Matija to assess whether the almost-finished
+product solves the stated problems. If there are any obvious problems, they may
+or may not be adjusted in final tweaks, depending on available time and
+resources.
+
+### Version control
+
+During the implementation, version control will be used. It is likely that Git
+will be used, by far the most common version control system. The advantages of
+using version control are many, but as it pertains to quality assurances, the
+benefits are as follows:
+
+- VCS diffs make code reviews much easier. The diffs show exactly what has
+  changed between revisions.
+- VCS allows one to easily revert changes if a certain set of commits proved to
+  be harmful to quality.
+- If applied well, VCS assures that your changes in every commit have a clear
+  and confined scope. This is conducive to quality.
+
+### Documentation
+
+Documentation will be produced along the way. Four kinds of documentation can
+be easily identified from this plan de campagne:
+
+- The plan de campagne itself.
+- The requirements analysis.
+- The report.
+- The integration document.
+
+The plan de campagne is conducive to quality by outlining important details of
+the project in advance. The requirements analysis improves quality by defining
+exactly what must be done. The intent is that, if those things are done, you
+will have a good product.
+
+The report is less important to quality along the way, but will be valuable for
+retrospective.
+
+The integration document facilitates quality along the way because it forces the
+implementer to be mindful about how the product might be integrated, and to
+concretely write those things down. The hope is that the document will be useful
+to the integrator.
+
+A fifth method of documentation has not been mentioned in the document yet
+because I believe it to be self-evident, but will be mentioned here for
+posterity's sake: There will be in-code documentation. Ideally, all classes,
+methods, and functions have a short description of their behaviour. All tests
+should describe what they are testing without having to read the code. The tests
+also double as documentation of their own, because they define the intended
+behaviour of the code. Ideally this in-code documentation is a single source of
+truth that the integration document can refer to. In my own experience, in-code
+documentation improves the quality in two facets:
+
+- It is much easier for third parties to read and adopt code that is
+  well-documented.
+- The act of documenting classes and functions forces the writer to think very
+  clearly about its behaviour, and whether it abides by the
+  single-responsibility principle. Function and variable names are equally as
+  important in this.
+
+### Issue tracker
+
+In line with things that are obvious but stated for posterity's sake: I will
+make heavy use of an issue tracker. I do not yet know which, but that ultimately
+matters little. An issue tracker is conducive to quality by clearly defining
+what needs to be done. My own experience with working without an issue tracker
+is that the programming becomes very meandering and does not solve precisely
+what needs to be solved. To prevent that, an issue tracker is fantastic.
+
+An issue tracker is also an excellent platform for discussions that can be
+referred back to later. This is valuable even if there is no conversation
+partner.
+
+The issues, together with the requirements analysis, double as "definitions of
+done", which help focus the work on the needed areas.
+
+## Development model
+
+The chosen development model is waterfall, or some variation thereof. This isn't
+an active choice that was made, but a logical result of the demands as put
+forward by school. A lot of up-front work must be done (writing this plan de
+campagne, doing research, making a requirements analysis, coming up with a
+design, etc.), which is simply not "Agile". It is, however, very much in line
+with waterfall.
+
+Waterfall typically comes with five steps (requirements, design, implementation,
+verification, maintenance). The first three steps are already mandated by
+school, in that order. The fourth and fifth step are less applicable to this
+internship. Explaining why maintenance is not applicable is easy: I will not be
+maintaining anything during or after my internship. Verification is less
+applicable because a lot of the verification happens *during* the implementation
+as part of test-driven development. Although, as per section
+\ref{retrospective}, there will be some verification after implementation.
+
+Whether waterfall is the best choice, I can't confidently say. But given the
+requirements, it is the most logical choice.
+
 # Planning {#planning}
 
 This chapter covers the timing and planning of the internship. It is expressly
 kept short in the interest of being to-the-point. For more details, see chapter
 \ref{project-activities}.
 
-## Chronological planning
-
 The format is MM-DD. The year is implicitly 2020.
 
 - 02-03 --- Begin internship.
@@ -826,20 +1038,20 @@ The format is MM-DD. The year is implicitly 2020.
 
 - 03-24 --- Workshop analysis and conclusions.
 
-- 03-27 --- **Internal deadline: Research.**
+- 04-10 --- **Internal deadline: Research.**
 
-- 03-30 --- Create requirements analysis.
+- 04-13 --- Create requirements analysis.
 
 - 04-06 --- On-location meeting. This date is *not final*.
 
-- 04-06 --- Begin implementation period.
-
-- 04-15 --- Legal and Licensing Workshop in Barcelona.
+- 04-20 --- Begin implementation period.
 
 - 05-04 --- Workshop reporting.
 
 - 05-25 --- First draft report.
 
+- 05-26 --- Product retrospective.
+
 - 06-05 --- **Internal deadline: Hand over proof-of-concept.**
 
 - 06-05 --- Cease implementation period.
@@ -855,21 +1067,6 @@ six: Plan de campagne, research, synchronisation, implementation, reporting, and
 presentation. These six segments are colour-coded. Workshops, drafts, and
 deadlines get their own colours: soft blue, white, and soft pink respectively.
 
-## Legal and Licensing Workshop
-
-The Free Software Foundation Europe annually organises the Legal and Licensing
-Workshop (LLW) in Barcelona. Due to my work on REUSE and my field expertise in
-copyright and licensing, I have been invited to attend. The LLW is not strictly
-related to the internship, but it is a wonderful opportunity for professional
-growth, networking, and learning.
-
-Moreover, there will be plenty field experts present at the event. Although the
-research phase is over by April, there will be the opportunity to pick the
-brains of these experts. Some of these experts may be the \glspl{author} of
-solutions mentioned in research sub-question @solutions.
-
-See also section \ref{spdx-reuse}.
-
 \appendix
 
 # Crash course in copyright and licensing {#crash-course}
@@ -887,13 +1084,14 @@ creative work is fixed in tangible form. [...] In some jurisdictions, creators
 may be required to register with a national agency in order to enforce
 \gls{copyright} in court."
 
-The Berne Convention [-@berne-1886] is an international agreement between
-nations that forms the basis of much of \gls{copyright} law. It grants foreign
-works the same protections as native works, and sets some minimum standards of
-protection that all signatories must meet. The Berlin Act [-@berlin-1908]
-introduces the concept that \gls{copyright} is enjoyed without being "subject to
-any formality". In effect, this means that \gls{copyright} is granted as soon as
-one's metaphorical pen is put to paper.
+The Berne Convention by Bureaux Internationaux Réunis pour la Protection de la
+Propriété Intellectuelle [BIRPI, -@berne-1886] is an international agreement
+between nations that forms the basis of much of \gls{copyright} law. It grants
+foreign works the same protections as native works, and sets some minimum
+standards of protection that all signatories must meet. The Berlin Act [BIRPI,
+-@berlin-1908] introduces the concept that \gls{copyright} is enjoyed without
+being "subject to any formality". In effect, this means that \gls{copyright} is
+granted as soon as one's metaphorical pen is put to paper.
 
 In order for a work to be eligible for \gls{copyright}, it must be original. In
 this context, "'[o]riginal' means a work created through the 'fruits of
@@ -914,7 +1112,7 @@ life of the \gls{author} and 70 years after their death, or 70 years after the
 first lawful publication in case the \gls{author} is anonymous/pseudonymous.
 [@copyright-term-directive]
 
-The Berne Convention [-@berne-1886] and many other sources use the word
+The Berne Convention [BIRPI, -@berne-1886] and many other sources use the word
 "\gls{author}" to refer to the person or organisation that holds the rights over
 a certain work. In this document, "\gls{copyright-holder}" is consistently used
 instead. The reason for this is that the \gls{author} is not always the
